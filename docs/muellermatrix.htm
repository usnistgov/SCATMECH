<html>
<head>
<link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
  <meta name="generator" content=
  "HTML Tidy for Cygwin (vers 1st September 2004), see www.w3.org">
   <link rel="STYLESHEET" href="style.css" type="text/css">

  <title>SCATMECH: MuellerMatrix</title>
<script language="JavaScript" id="_fed_an_js_tag" src="/js/federated-analytics.all.min.js?agency=NIST&subagency=pml&pua=UA-37115410-46&yt=true"></script>
</head>

<body><br>
  <table width="98%" border="0" cellpadding="0" cellspacing="0" align="center">
    <tr>
      <td>
        <a name="top" id="top"><!-- --></a>
        <p class="nav"><a href="index.htm">SCATMECH</a> &gt; <a href=
        "classes.htm">Classes and Functions</a> &gt;
        <a href="classes.htm#Pol">Polarization</a> &gt; MuellerMatrix</p>

        <h1><a name="Pol" id="Pol">class MuellerMatrix</a></h1>

        <hr>

        <p>The class <b>MuellerMatrix</b> represents a Mueller matrix
        in the Stokes-Mueller representation of polarization
        states. Arithmetic operations between Mueller matrices and
        Stokes vectors, various properties of a Mueller matrix, and
        transformation operations are defined.

	<h2>Include  file:</h2>

          <pre>
#include "<a href="../code/mueller.h">mueller.h</a>"
</pre>
        <h2>See also:</h2>

        <p><a href="index.htm">SCATMECH Home</a>, &nbsp;
        <a href="convent.htm">Conventions</a>, &nbsp; <a href=
        "stokesvector.htm">StokesVector</a>, &nbsp; <a href=
        "jonesmatrix.htm">JonesMatrix</a>, &nbsp; <a href=
        "jonesvector.htm">JonesVector</a></p>

        <p>
	<a name="RefBohren" id="RefBohren"></a><a href="http://dx.doi.org/10.1002/9783527618156">C.F. Bohren and D.R. Huffman, <i>Absorption and Scattering of Light by Small Particles</i>, (Wiley, New York, 1983).</a><br>
        <a name="RefHulst" id="RefHulst"></a><a href="https://books.google.com/books?hl=en&lr=&id=PlHfPMVAFRcC&oi=fnd&pg=PA1&ots=Gg_gMuimH7&sig=gqf0sZ1ELYIDmyxa0vLzXIPcLWs">H.C. van de Hulst, <i>Light Scattering by Small Particles</i>, (Dover, New York, 1981).</a><br>
        <a name="RefChipman" id="RefChipman"></a><a href="https://books.google.com/books/about/Handbook_of_Optics_Fundamentals_techniqu.html?id=ggc6AQAAIAAJ">R.A. Chipman, &quot;Polarimetry.&quot; in <i>Handbook of Optics</i>, (McGraw-Hill, New York, 1995).</a><br>
	<a name="RefGivens" id="RefGivens"></a><a href="http://dx.doi.org/10.1080/09500349314550471">C.R. Givens and A.B. Kostinski, &quot;A simple necessary and sufficient condition on physically realizable Mueller matrices,&quot; J. Mod. Opt. <b>40</b>, 471 (1993).</a><br>
	<a name="RefSimon" id="RefSimon"></a><a href="https://doi.org/10.1364/JOSAA.27.000188">B.N. Simon, et al., &quot;A complete characterization of pre-Mueller and Mueller matrices in polarization optics,&quot; J. Opt. Soc. Am. A <b>27</b>(2), 188-199 (2010).</a><br>
	<a name="RefLuChipman" id="RefLuChipman"></a><a href="https://doi.org/10.1364/JOSAA.13.001106">S.-Y. Lu and R.A. Chipman, &quot;Interpretation of Mueller matrices based on polar decomposition,&quot; J. Opt. Soc. Am. A <b>13</b>(5), 1106-1113 (1996).</a> <br>

	<h2>Definition of public elements:</h2>

        <blockquote>
          <pre>
class MuellerMatrix {
    public:
        <a href="#MuellerMatrix()">MuellerMatrix</a>();
        <a href="#MuellerMatrix(constJonesMatrix)">MuellerMatrix</a>(const <a href="jonesmatrix.htm">JonesMatrix</a>&amp; j);
        <a href="#MuellerMatrix(constMuellerMatrix)">MuellerMatrix</a>(const MuellerMatrix&amp; x);
        MuellerMatrix&amp; <a href="#operatore(constMuellerMatrix)">operator=</a>(const MuellerMatrix&amp; x);
        double* <a href="#operatorat(int)">operator[]</a>(int i);
        const double* <a href="#operatorat(int)">operator[]</a>(int i) const;
        double <a href="#Tmax()">Tmax</a>() const;
        double <a href="#Tmin()">Tmin</a>() const;
        double <a href="#diattenuation()">diattenuation</a>() const;
        double <a href="#linear_diattenuation()">linear_diattenuation</a>() const;
	double <a href="#depolarizationindex">depolarization_index</a>() const;
        double <a href="#polarization_dependent_loss()">polarization_dependent_loss</a>() const;
        double <a href="#polarizance()">polarizance</a>() const;
        double <a href="#extinction_ratio()">extinction_ratio</a>() const;
	bool <a href="#valid()">valid</a>() const;
	bool <a href="#valid()">physically_valid</a>() const;
        MuellerMatrix <a href="#rotate(double)">rotate</a>(double angle) const;
        MuellerMatrix <a href="#parity()">parity</a>() const;
        MuellerMatrix <a href="#transpose()">transpose</a>() const;
	MuellerMatrix <a href="#inverse()">inverse</a>() const;
	MuellerMatrix <a href="#log()">log</a>() const;
	MuellerMatrix <a href="#exp()">exp</a>() const;
	MuellerMatrix <a href="#normalized()">normalized</a>() const;
	void <a href="#Cloude">Cloude_Decomposition</a>(MuellerMatrix& M1,MuellerMatrix& M2,MuellerMatrix& M3, MuellerMatrix& M4) const;
	MuellerMatrix <a href="#closest">Closest_NonDepolarizing</a>() const;
	void <a href="#LuChipman">Lu_Chipman_Decomposition</a>(MuellerMatrix& depolarizer,MuellerMatrix& retarder,MuellerMatrix& diattenuator) const;
        MuellerMatrix <a href="#operatort(constMuellerMatrix)">operator*</a>(const MuellerMatrix&amp; matrix) const;
        MuellerMatrix&amp; <a href="#operatorte(MuellerMatrix)">operator*=</a>(const MuellerMatrix&amp; matrix);
        MuellerMatrix <a href="#operatort(double)">operator*</a>(double d) const;
        friend MuellerMatrix <a href="#operatort(doubleconstMuellerMatrix)">operator*</a>(double d,const MuellerMatrix &amp;v);
        <a href="stokesvector.htm">StokesVector</a> <a href="#operatort(constStokesVector)">operator*</a>(const <a href="stokesvector.htm">StokesVector</a>&amp; s) const;
        MuellerMatrix&amp; <a href="#operatorte(double)">operator*=</a>(double d);
        MuellerMatrix <a href="#operatord(double)">operator/</a>(double d) const;
        MuellerMatrix&amp; <a href="#operatorde(double)">operator/=</a>(double d);
        MuellerMatrix <a href="#operatorp(constMuellerMatrix)">operator+</a>(const MuellerMatrix&amp; a) const;
        MuellerMatrix <a href="#operatorm(constMuellerMatrix)">operator-</a>(const MuellerMatrix&amp; a) const;
        MuellerMatrix <a href="#operatorm()">operator-</a>() const;
        MuellerMatrix&amp; <a href="#operatorpe(MuellerMatrix)">operator+=</a>(MuellerMatrix&amp; matrix);
        MuellerMatrix&amp; <a href="#operatorme(MuellerMatrix)">operator-=</a>(MuellerMatrix&amp; matrix);
};

ostream&amp; <a href="#operatorltlt">operator&lt;&lt;</a>(ostream&amp; os,const MuellerMatrix&amp; mm);
istream&amp; <a href="#operatorgtgt">operator&gt;&gt;</a>(istream&amp; is, MuellerMatrix&amp; mm);
</pre>
        </blockquote>
        <hr>

        <h3><a name="MuellerMatrix()" id="MuellerMatrix()">MuellerMatrix()</a></h3>

	<blockquote>
        <p>The default constructor for a <b>MuellerMatrix</b> does not
          initialize any of the elements.
	  </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="MuellerMatrix(constJonesMatrix)" id="MuellerMatrix(constJonesMatrix)">
	    MuellerMatrix(const JonesMatrix&amp; j)</a></h3>

        <blockquote>
          <p>Constructor that converts a <a href=
          "jonesmatrix.htm">JonesMatrix</a> to a
          <b>MuellerMatrix</b>, using the algorithm described by <a href="#RefBohren">Bohren and Huffman.</a>
        <h4>Example:</h4>

          <pre>
JonesMatrix j;
MuellerMatrix m(j); // Conversion from a Jones matrix to a Mueller matrix.
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>
	
	<h3><a name="MuellerMatrix(constMuellerMatrix)" id="MuellerMatrix(constMuellerMatrix)">
	    MuellerMatrix(const MuellerMatrix&amp; x)</a></h3>

        <blockquote>
        <p>The copy constructor.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a;
MuellerMatrix b(a);
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatore(constMuellerMatrix)" id="operatore(constMuellerMatrix)">
	    MuellerMatrix&amp; operator=(const MuellerMatrix&amp; x)</a></h3>

        <blockquote>
        <p>The assignment operator.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a;
MuellerMatrix b=a;

</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>


	<h3><a name="operatorat(int)" id="operatorat(int)">
	    double* operator[](int i)<br>
        const double* operator[](int i) const</a></h3>

        <blockquote>
          <p>Operators to access specific elements of the
          <b>MuellerMatrix</b>.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a;
double b=a[0][0]; // Access the 00 term of the Mueller matrix
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="Tmax()" id="Tmax()">double Tmax() const</a><br>
        <a name="Tmin()" id="Tmin()">double Tmin() const</a><br>
        <a name="diattenuation()" id="diattenuation()">double diattenuation() const</a><br>
        <a name="linear_diattenuation()" id="linear_diattenuation()">double linear_diattenuation() const</a><br>
        <a name="polarization_dependent_loss()" id="polarization_dependent_loss()">double polarization_dependent_loss() const</a><br>
        <a name="polarizance()" id="polarizance()">double polarizance() const</a><br>
        <a name="extinction_ratio()" id="extinction_ratio()">double extinction_ratio() const</a><br>
	<a name="depolarizationindex" id="depolarizationindex">double depolarization_index() const</a>
	</h3>

        <blockquote>
         <p> Functions to return the maximum and minimum
          transmissivity, the diattenuation, the linear
          diattenuation, the polarization-dependent loss, the
          polarizance, the extinction ratio, and the depolarization index, respectively, for the given
          Mueller matrix. These terms are defined in <a href="#RefChipman">Chipman</a>.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a;
cout &lt;&lt; "Tmax = " &lt;&lt; a.Tmax() &lt;&lt; endl
     &lt;&lt; "Tmin = " &lt;&lt; a.Tmin() &lt;&lt; endl
     &lt;&lt; "diattenuation = " &lt;&lt; a.diattenuation() &lt;&lt; endl
     &lt;&lt; "lineardiattenuation = " &lt;&lt; a.lineardiattenuation() &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	
	<h3><a name="valid()" id="valid()">bool valid() const<br>
	bool physically_valid() const</a></h3>

	<blockquote>
          <p>The function <b>valid()</b> uses the criterion described by 
	  <a href="#RefGivens">Givens and Kostinski</a> to test if the
          matrix is a mapping from the space of valid Stokes vectors
          to itself. The function <b>physically_valid()</b> tests the
          criterion that a Mueller matrix must be a convex sum (i.e.,
          a sum of positive Mueller matrices) of Jones-Mueller
          matrices, as described by <a href="#RefSimon">Simon, et
          al.</a>.  The function <b>physically_valid()</b> is a more
          stringent requirement that a physical Mueller matrix must
          satisfy.

        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="rotate(double)" id="rotate(double)">
	    MuellerMatrix rotate(double angle) const</a></h3>

	<blockquote>
          <p>Function that returns a <b>MuellerMatrix</b> rotated by
          <b>angle</b> in the clockwise direction, looking into the
          beam.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a,b;
b = a.rotate(45*PI/180.);
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "parity()" id="parity()">MuellerMatrix parity()
        const</a></h3>

        <blockquote>
         <p> Function that returns a <b>MuellerMatrix</b> that has
          undergone a mirror operation.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a,b;
b = a.parity();
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "transpose()" id="transpose()">MuellerMatrix transpose()
        const</a></h3>

        <blockquote>
         <p> Function that returns the transpose of a
          <b>MuellerMatrix</b>.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a,b;
b = a.transpose();
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "inverse()" id="inverse()">MuellerMatrix inverse()
        const</a></h3>

        <blockquote>
         <p> Function that returns the inverse of a
          <b>MuellerMatrix</b>.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a,b;
b = a.inverse();
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>


	<h3><a name="log()" id="log()">MuellerMatrix log() const</a><br>
	  <a name="exp()" id="exp()">MuellerMatrix exp() const</a></h3>

        <blockquote>
         <p> Functions that return the matrix logarithm and exponent of a <b>MuellerMatrix</b>.

        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="normalized()" id="normalized()">MuellerMatrix normalized() const</a></h3>

        <blockquote>
         <p> Function that returns the Mueller matrix normalized by the 00 element.

        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="Cloude" id="Cloude">void Cloude_Decomposition(MuellerMatrix& M1,MuellerMatrix& M2,MuellerMatrix& M3, MuellerMatrix& M4) const</a></h3>

	<blockquote>
	  <p>Function that decomposes the Mueller matrix into the sum of four non-depolarizing Mueller matrices, as described by <a href="#RefCloude">Cloude</a>.</p>

        <h4>Example:</h4>

          <pre>
MuellerMatrix m = MuellerMatrix(JonesMatrix(1,1,0,0))+MuellerMatrix(JonesMatrix(1,-2,0,0));
MuellerMatrix m1,m2,m3,m4;
m.Cloude_Decomposition(m1,m2,m3,m4);
cout << m - m1 - m2 - m3 - m4 << endl; // should be close to the zero matrix
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="closest" id="closest">MuellerMatrix Closest_NonDepolarizing() const</a></h3>

	<blockquote>
	  <p>Function that returns the largest of the matrices returned by <a href="#Cloude">Cloude_Decomposition</a>. </p>

          <pre>
MuellerMatrix m;
cout << m.Closest_NonDepolarizing() << endl; 
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="LuChipman" id="LuChipman">
	    void Lu_Chipman_Decomposition(MuellerMatrix& depolarizer, MuellerMatrix& retarder, MuellerMatrix& diattenuator) const</a></h3>

        <blockquote>
         <p> Function that decomposes the Mueller matrix into the product of a depolarizer, a retarder, and a diattenuator,
	   according to <a href= "#RefLuChipman">Lu and Chipman</a>.

        <h4>Example:</h4>

          <pre>
MuellerMatrix a,depolarizer,retarder,diattenuator;
a.Lu_Chipman_Decomposition(depolarizer,retarder,diattenuator);
cout << a - depolarizer*retarder*diattenuator; // should be close to the zero matrix
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatort(constMuellerMatrix)" id="operatort(constMuellerMatrix)"><!-- --></a>MuellerMatrix operator*(const MuellerMatrix&amp; matrix) const<br>
        <a name="operatorte(MuellerMatrix)" id="operatorte(MuellerMatrix)"><!-- --></a>MuellerMatrix&amp; operator*=(const MuellerMatrix&amp; matrix)</h3>

        <blockquote>
         <p> Binary multiplication between two <b>MuellerMatrix</b>
          objects. If <b>matrix2</b> is followed by <b>matrix1</b>,
          then <b>matrix1*matrix2</b> returns the net
          <b>MuellerMatrix</b>. This operator is not commutative.
        <h4>Example:</h4>

          <pre>
MuellerMatrix a,b,c;
c = a*b;
a *= b;  // Same as a = a*b;

</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatort(double)" id="operatort(double)">MuellerMatrix operator*(double d) const<br></a> 
	  <a name="operatort(doubleconstMuellerMatrix)" id="operatort(doubleconstMuellerMatrix)">friend MuellerMatrix operator*(double d,const MuellerMatrix&amp;v)</a><br>
        <a name="operatorte(double)" id="operatorte(double)">MuellerMatrix&amp; operator*=(double d)</a><br>
        <a name="operatord(double)" id="operatord(double)">MuellerMatrix operator/(double d) const</a><br>
        <a name="operatorde(double)" id="operatorde(double)">MuellerMatrix&amp; operator/=(double d)</a></h3>

        <blockquote>
         <p>Multiplication and division of a <b>MuellerMatrix</b> by
          a scalar.
        <h4>Example:</h4>

          <pre>
double scalar;
MuellerMatrix matrix;
matrix = matrix * scalar;
matrix = scalar * matrix;
matrix *= scalar;
matrix = matrix / scalar;
matrix = scalar / matrix; // Not allowed.
matrix /= scalar;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatort(constStokesVector)" id="operatort(constStokesVector)">
	    StokesVector operator*(const StokesVector &amp;s) const</a></h3>

        <blockquote>
         <p> Left multiplication of a <a href=
          "stokesvector.htm">StokesVector</a> by a
          <b>MuellerMatrix</b>.
        <h4>Example:</h4>

          <pre>
MuellerMatrix matrix;
StokesVector vector;
vector = matrix*vector;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatorp(constMuellerMatrix)" id="operatorp(constMuellerMatrix)">MuellerMatrix operator+(const MuellerMatrix&amp; a) const</a><br>
        <a name="operatorm(constMuellerMatrix)" id="operatorm(constMuellerMatrix)">MuellerMatrix operator-(const MuellerMatrix&amp; a) const</a><br>
        <a name="operatorpe(MuellerMatrix)" id="operatorpe(MuellerMatrix)">MuellerMatrix&amp; operator+=(MuellerMatrix&amp; matrix)</a><br>
        <a name="operatorme(MuellerMatrix)" id="operatorme(MuellerMatrix)">MuellerMatrix&amp; operator-=(MuellerMatrix&amp; matrix)</a></h3>

        <blockquote>
        <p>Addition and subtraction of <b>MuellerMatrix</b> objects.
        <h4>Example:</h4>

          <pre>
MuellerMatrix matrix1,matrix2,matrix3;
matrix3=matrix1+matrix2;
matrix3=matrix1-matrix2;
matrix1+=matrix2;
matrix1-=matrix2;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h4><a name="operatorm()" id="operatorm()">MuellerMatrix operator-()
        const</a></h4>

        <blockquote>
         <p>Negation of a <b>MuellerMatrix</b>.
        <h4>Example:</h4>

          <pre>
MuellerMatrix matrix;
matrix=-matrix;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>
	
	<h3>
        <a name="operatorltlt" id="operatorltlt">
        ostream&amp; operator&lt;&lt;(ostream&amp; os,const MuellerMatrix&amp; mm)</a></h3>

        <blockquote>
         <p> Operator to send a <b>MuellerMatrix</b> to an
          <b>ostream</b>. The result will contain four Stokes vectors, representing each of the four rows, separated by commas, and surrounded by 
	  parentheses, e.g., <tt>((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))</tt>. 
	  <h4>Example:</h4>
	  <pre>
MuellerMatrix M;
cout << "M = " << M << endl;
</pre>

        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3>
        <a name="operatorgtgt" id="operatorgtgt">
        istream&amp; operator&gt;&gt;(istream&amp; is, MuellerMatrix&amp; mm)</a></h3>

        <blockquote>
          <p>Reads a <b>MuellerMatrix</b> from an input stream. The input string must contain 
	    four Stokes vectors, representing each of the four rows, separated by commas, and surrounded by 
	  parentheses, e.g., <tt>((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))</tt>. 
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

<!-- START FOOTER -->
<hr>
<h2>For More Information</h2>

<p>
<a href="http://www.nist.gov/pml/div685/grp06/germer.cfm">SCATMECH Technical Information and Questions</a><br>
<a href="http://www.nist.gov/pml/div685/index.cfm" target="_top">Sensor Science Division Home Page</a><br>
<a href="mailto:fraser@nist.gov">Sensor Science Division Inquiries</a><br>
<a href="mailto:thomas.germer@nist.gov">Website Comments</a>

<p>
Current SCATMECH version: <a href="./download.htm">7.01 (September 2017)</a><br>
<br>

</td>
</tr>
</table>

</body>
</html>
